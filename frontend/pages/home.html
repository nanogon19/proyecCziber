<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>DataSage</title>
  <link rel="stylesheet" href="../styles/consulta.css">
  <link href="https://unpkg.com/gridjs/dist/theme/mermaid.min.css" rel="stylesheet" />
  <script src="https://unpkg.com/gridjs/dist/gridjs.umd.js"></script>
  <script src="https://cdnjs.cloudflar      const listarConexiones = async () => {
        setLoading(true);
        try {
          const data = await apiCall(CONFIG.ENDPOINTS.LISTAR_CONEXIONES);libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <!-- React y Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Configuración del backend -->
  <script src="../config.js"></script>
</head>
<body>
  <div id="root">
    <div style="padding: 20px; text-align: center; background: #444; color: white; height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center;">
      <h2>Cargando DataSage...</h2>
      <p>Si esta página no se carga completamente, revisa la consola del navegador (F12).</p>
      <div style="margin-top: 20px;">
        <div style="display: inline-block; width: 20px; height: 20px; background: #f4b142; border-radius: 50%; animation: bounce 1s infinite;"></div>
      </div>
    </div>
  </div>

  <style>
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
      }
      40% {
        transform: translateY(-10px);
      }
      60% {
        transform: translateY(-5px);
      }
    }
  </style>

  <!-- Carga el componente React directamente embebido -->
  <script type="text/babel">
    function DataSageHome() {
      const [prompt, setPrompt] = React.useState("");
      const [results, setResults] = React.useState([]);
      const [showConexiones, setShowConexiones] = React.useState(false);
      const [conexiones, setConexiones] = React.useState([]);
      const [loading, setLoading] = React.useState(false);
      const [queryLoading, setQueryLoading] = React.useState(false);
      const [currentView, setCurrentView] = React.useState("listar");
      const [formData, setFormData] = React.useState({
        ip: "",
        port: "",
        database_name: ""
      });
      const [tempConnectionData, setTempConnectionData] = React.useState(null); // Datos temporales antes del login
      const [showLoginModal, setShowLoginModal] = React.useState(false);
      const [showCreateConnectionModal, setShowCreateConnectionModal] = React.useState(false); // Nuevo modal para credenciales
      const [selectedConnection, setSelectedConnection] = React.useState(null);
      const [loginData, setLoginData] = React.useState({
        username: "",
        password: ""
      });
      const [currentConnectionString, setCurrentConnectionString] = React.useState("");
      const [authenticatedCredentials, setAuthenticatedCredentials] = React.useState(null); // Guardar credenciales autenticadas

      // Agregar datos de prueba para testing
      const addTestData = () => {
        const testResult = {
          id: Date.now(),
          prompt: "SELECT * FROM usuarios LIMIT 5",
          columns: ["ID", "Nombre", "Email", "Fecha"],
          data: [
            [1, "Juan Pérez", "juan@email.com", "2024-01-01"],
            [2, "María García", "maria@email.com", "2024-01-02"],
            [3, "Carlos López", "carlos@email.com", "2024-01-03"],
            [4, "Ana Martín", "ana@email.com", "2024-01-04"],
            [5, "Luis Rodríguez", "luis@email.com", "2024-01-05"]
          ],
          timestamp: new Date().toLocaleString()
        };
        setResults(prev => [...prev, testResult]);
      };

      const loadConexiones = async () => {
        try {
          const data = await apiCall(CONFIG.ENDPOINTS.LISTAR_CONEXIONES);
          setConexiones(data.conexiones || []);
        } catch (error) {
          console.error("Error al cargar conexiones:", error);
          alert("Error al cargar las conexiones disponibles");
        }
      };

      const handleSelectConnection = (conexion) => {
        setSelectedConnection(conexion);
        setShowConexiones(false);
        setShowLoginModal(true);
      };

      const handleLogin = async (e) => {
        e.preventDefault();
        if (!selectedConnection || !loginData.username || !loginData.password) {
          alert("Complete todos los campos");
          return;
        }

        try {
          const result = await apiCall(CONFIG.ENDPOINTS.LOGIN_CONEXION, {
            method: 'POST',
            body: JSON.stringify({
              conexion_id: selectedConnection.id_conn,
              username: loginData.username,
              password: loginData.password
            })
          });
          
          console.log("Respuesta del login:", result);
          
          if (result.error) {
            alert(result.error + (result.details ? "\n\nDetalles: " + result.details : ""));
            return;
          }

          if (result.message === "Login exitoso" && result.conexion_info) {
            // Guardar la información de la conexión exitosa y las credenciales
            setCurrentConnectionString(`conexion_${selectedConnection.id_conn}_authenticated`);
            setAuthenticatedCredentials({
              conexion_id: selectedConnection.id_conn,
              username: loginData.username,
              password: loginData.password
            });
            setShowLoginModal(false);
            setLoginData({ username: '', password: '' }); // Limpiar el formulario pero mantener las credenciales autenticadas
            alert(`Conectado exitosamente a ${selectedConnection.ip}:${selectedConnection.puerto || selectedConnection.port}/${selectedConnection.database}`);
          } else {
            alert("Respuesta inesperada del servidor");
          }

        } catch (error) {
          console.error("Error al conectar:", error);
          alert("Error al intentar conectar a la base de datos: " + error.message);
        }
      };

      // Cargar conexiones al iniciar
      React.useEffect(() => {
        loadConexiones();
      }, []);

      const handleSubmit = async (e) => {
        e.preventDefault();
        if (!prompt.trim()) return;

        // Verificar si hay una conexión activa
        if (!authenticatedCredentials && !selectedConnection) {
          alert("Debe seleccionar y conectarse a una base de datos primero");
          setShowConexiones(true);
          return;
        }

        setQueryLoading(true);
        
        // Scroll inmediato al mostrar el loading
        setTimeout(() => {
          const resultBox = document.getElementById('resultBox');
          if (resultBox) {
            resultBox.scrollTop = resultBox.scrollHeight;
          }
        }, 50);
        
        try {
          const requestBody = {
            prompt: prompt
          };

          // Si tenemos credenciales autenticadas, usarlas
          if (authenticatedCredentials) {
            requestBody.conexion_id = authenticatedCredentials.conexion_id;
            requestBody.username = authenticatedCredentials.username;
            requestBody.password = authenticatedCredentials.password;
          } else {
            alert("Debe autenticarse en una conexión primero");
            setShowConexiones(true);
            setQueryLoading(false);
            return;
          }

          console.log("Enviando consulta con datos:", {
            prompt: requestBody.prompt,
            conexion_id: requestBody.conexion_id,
            username: requestBody.username
            // No logear la contraseña por seguridad
          });

          const json = await apiCall(CONFIG.ENDPOINTS.CONSULTAR, {
            method: 'POST',
            body: JSON.stringify(requestBody)
          });
          console.log("Respuesta del servidor:", json);
          
          if (json.mensaje) {
            alert(json.mensaje);
            setQueryLoading(false);
            return;
          }

          const { columns, data } = json;
          
          // Agregar resultado a la lista
          const newResult = {
            id: Date.now(),
            prompt: prompt,
            columns: columns,
            data: data,
            timestamp: new Date().toLocaleString()
          };

          setResults(prev => [...prev, newResult]);
          setPrompt("");

          // Desplazarse automáticamente hacia abajo después de agregar la nueva respuesta
          setTimeout(() => {
            const resultBox = document.getElementById('resultBox');
            if (resultBox) {
              resultBox.scrollTop = resultBox.scrollHeight;
            }
          }, 100);

        } catch (error) {
          console.error("Error al enviar la consulta:", error);
          alert("Error al enviar la consulta. Por favor, inténtelo de nuevo.");
        } finally {
          setQueryLoading(false);
        }
      };

      const exportToExcel = React.useCallback((result) => {
        const worksheetData = [result.columns, ...result.data];
        const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "Resultado");

        const filename = `consulta_${Date.now()}.xlsx`;
        XLSX.writeFile(workbook, filename);
      }, []);

      // Definir DataGrid antes de usarlo en useMemo
      const DataGrid = React.memo(({ columns, data }) => {
        const gridRef = React.useRef(null);
        const gridInstanceRef = React.useRef(null);

        React.useEffect(() => {
          console.log("DataGrid useEffect ejecutado - ID de datos:", data?.[0]?.[0]);
          
          if (gridRef.current && columns && data && columns.length > 0 && data.length > 0) {
            // Si ya existe una instancia del grid, destruirla primero
            if (gridInstanceRef.current) {
              try {
                gridInstanceRef.current.destroy();
              } catch (e) {
                console.log("Error al destruir grid anterior:", e);
              }
            }
            
            gridRef.current.innerHTML = '';
            
            try {
              const grid = new gridjs.Grid({
                columns: columns,
                data: data,
                pagination: {
                  enabled: true,
                  limit: 10
                },
                search: true,
                sort: true,
                resizable: true,
                fixedHeader: true,
                height: '400px',
                width: '100%',
                style: {
                  table: {
                    'border-radius': '10px',
                    'overflow': 'hidden',
                    'box-shadow': '0 2px 10px rgba(0, 0, 0, 0.1)',
                    'width': '100%'
                  },
                  th: {
                    'background-color': '#f4b142',
                    'color': '#fff',
                    'text-align': 'center',
                    'padding': '12px'
                  },
                  td: {
                    'text-align': 'center',
                    'padding': '8px'
                  }
                }
              });
              
              grid.render(gridRef.current);
              gridInstanceRef.current = grid;
              console.log("Grid renderizado exitosamente");
            } catch (error) {
              console.error('Error rendering grid:', error);
              gridRef.current.innerHTML = '<p style="color: red; padding: 20px;">Error al cargar la tabla: ' + error.message + '</p>';
            }
          }

          // Cleanup function
          return () => {
            if (gridInstanceRef.current) {
              try {
                gridInstanceRef.current.destroy();
              } catch (e) {
                console.log("Error en cleanup del grid:", e);
              }
            }
          };
        }, [columns, data]);

        return (
          <div className="grid-container">
            <div ref={gridRef}></div>
          </div>
        );
      });

      // Memoizar los resultados para evitar re-renders
      const memoizedResults = React.useMemo(() => results, [results.length, results.map(r => r.id).join(',')]);
      
      // Memoizar el componente ResultBox completo
      const ResultBox = React.useMemo(() => {
        return (
          <div className="result-box" id="resultBox">
            {memoizedResults.length === 0 && !queryLoading ? (
              <div className="no-results">
                <p>No hay consultas realizadas aún. Escribe una consulta para comenzar.</p>
              </div>
            ) : (
              <>
                {memoizedResults.map((result) => (
                  <div key={result.id} className="result-item">
                    <div className="result-header">
                      <h3>Consulta: {result.prompt}</h3>
                      <button 
                        className="export-btn"
                        onClick={() => exportToExcel(result)}
                      >
                        Exportar a Excel
                      </button>
                    </div>
                    <DataGrid columns={result.columns} data={result.data} />
                  </div>
                ))}
                {queryLoading && (
                  <div className="loading-query">
                    <div className="loading-spinner"></div>
                    <p>Procesando consulta...</p>
                  </div>
                )}
              </>
            )}
          </div>
        );
      }, [memoizedResults, exportToExcel, queryLoading]);

      const listarConexiones = async () => {
        setLoading(true);
        try {
          const response = await fetch("http://localhost:5000/cziber/listar_todas_conexiones", {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
            },
          });

          if (response.ok) {
            const data = await response.json();
            setConexiones(data.conexiones);
            console.log("Conexiones obtenidas:", data.conexiones);
          } else {
            const errorData = await response.json();
            console.error("Error al obtener conexiones:", errorData.error);
            alert("Error al obtener conexiones: " + errorData.error);
          }
        } catch (error) {
          console.error("Error al conectar con el backend:", error);
          alert("No se pudo conectar con el servidor");
        }
        setLoading(false);
      };

      const handleSubmitConexion = async (e) => {
        e.preventDefault();
        
        // Validar que todos los campos estén completos
        const requiredFields = ['ip', 'port', 'database_name'];
        for (const field of requiredFields) {
          if (!formData[field]) {
            alert(`Por favor complete el campo: ${field}`);
            return;
          }
        }
        
        // Guardar datos temporalmente y abrir modal de credenciales
        setTempConnectionData(formData);
        setShowCreateConnectionModal(true);
        setLoginData({ username: '', password: '' });
      };

      // Nueva función para crear la conexión con credenciales
      const handleCreateConnectionWithCredentials = async (e) => {
        e.preventDefault();
        
        if (!tempConnectionData || !loginData.username || !loginData.password) {
          alert("Complete todos los campos incluyendo usuario y contraseña");
          return;
        }

        try {
          // Combinar datos de conexión con credenciales
          const connectionDataWithCredentials = {
            ...tempConnectionData,
            username: loginData.username,
            password: loginData.password
          };

          const response = await apiCall(CONFIG.ENDPOINTS.AGREGAR_CONEXION, {
            method: "POST",
            body: JSON.stringify(connectionDataWithCredentials)
          });

          if (response) {
            let successMessage = "Conexión creada exitosamente!";
            
            // Mostrar valores por defecto usados si están disponibles
            if (response.defaults_used) {
              successMessage += `\n\nValores asignados automáticamente:`;
              successMessage += `\n• Empresa: ${data.defaults_used.empresa}`;
              successMessage += `\n• Aplicación: ${data.defaults_used.aplicacion}`;
              successMessage += `\n• Modelo: ${data.defaults_used.modelo}`;
            }
            
            alert(successMessage);
            
            // Limpiar formularios y cerrar modales
            setFormData({
              ip: "",
              port: "",
              database_name: ""
            });
            setTempConnectionData(null);
            setLoginData({ username: '', password: '' });
            setShowCreateConnectionModal(false);
            setCurrentView("listar");
            
            // Actualizar la lista de conexiones
            listarConexiones();
          } else {
            const errorData = await response.json();
            alert("Error al crear conexión: " + errorData.error);
          }
        } catch (error) {
          console.error("Error creando conexión:", error);
          alert("Error al conectar con el servidor");
        }
      };

      const handleInputChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({
          ...prev,
          [name]: value
        }));
      };

      return (
        <div className="app-container">
          <div className="sidebar">
            <header>
              <p 
                className="conexiones" 
                onClick={() => {
                  setShowConexiones(true);
                  setCurrentView("listar");
                  listarConexiones();
                }}
                style={{ cursor: 'pointer' }}
              >
                Conexiones
              </p>
            </header>
            <h2>Consultas anteriores</h2>
            <div className="previous-queries">
              {results.length === 0 ? (
                <div className="no-queries">
                  <p>No hay consultas anteriores</p>
                </div>
              ) : (
                results.map((result, index) => (
                  <div key={result.id} className="query-item">
                    <div className="query-text">
                      {result.prompt.length > 50 ? 
                        `${result.prompt.substring(0, 50)}...` : 
                        result.prompt
                      }
                    </div>
                    <div className="query-time">
                      {result.timestamp}
                    </div>
                  </div>
                ))
              )}
            </div>
          </div>

          <div className="main-container">
            <header className="header">
              <div className="logo">DATASAGE</div>
              <img src="/proyecCziber/frontend/static/img/logo.png" alt="Logo" className="logo-img" />
            </header>

            {ResultBox}

            <form onSubmit={handleSubmit} className="input-area">
              <textarea 
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
                placeholder="Escriba su consulta aquí..."
                rows="3"
                disabled={queryLoading}
              />
              <button 
                type="submit" 
                disabled={!prompt.trim() || queryLoading}
              >
                {queryLoading ? "Procesando..." : "Enviar"}
              </button>
            </form>
          </div>

          {/* Modal de Conexiones */}
          {showConexiones && (
            <div className="modal-conexiones">
              <div className="contenido-conexiones">
                <span 
                  className="cerrar"
                  onClick={() => setShowConexiones(false)}
                >
                  &times;
                </span>
                <h2>Conexiones</h2>
                
                <div className="opciones-conexiones">
                  <p 
                    className={`conexion-op ${currentView === 'listar' ? 'active' : ''}`}
                    onClick={() => {
                      setCurrentView("listar");
                      listarConexiones();
                    }}
                  >
                    Listar conexiones
                  </p>
                  <p 
                    className={`conexion-op ${currentView === 'agregar' ? 'active' : ''}`}
                    onClick={() => {
                      setCurrentView("agregar");
                    }}
                  >
                    Agregar conexión
                  </p>
                </div>

                <div className="conexiones-content">
                  {currentView === "listar" ? (
                    <div className="conexiones-list">
                      {loading ? (
                        <div className="loading">Cargando conexiones...</div>
                      ) : conexiones.length === 0 ? (
                        <div className="no-conexiones">No hay conexiones disponibles</div>
                      ) : (
                        <>
                          <p style={{ marginBottom: '15px', color: '#666' }}>
                            Selecciona una conexión para conectarte:
                          </p>
                          {conexiones.map((conexion, index) => (
                            <div 
                              key={conexion.id_conn} 
                              className="conexion-item selectable"
                              onClick={() => handleSelectConnection(conexion)}
                              style={{
                                cursor: 'pointer',
                                border: selectedConnection?.id_conn === conexion.id_conn ? '2px solid #007bff' : '1px solid #ddd',
                                backgroundColor: selectedConnection?.id_conn === conexion.id_conn ? '#f0f8ff' : 'white'
                              }}
                            >
                              <div className="conexion-header">
                                <h4>{conexion.nombre || `Conexión #${index + 1}`}</h4>
                                <span className="conexion-id">{conexion.id_conn}</span>
                              </div>
                              <div className="conexion-details">
                                <p><strong>IP:</strong> {conexion.ip}</p>
                                <p><strong>Puerto:</strong> {conexion.puerto || conexion.port}</p>
                                <p><strong>Base de Datos:</strong> {conexion.database}</p>
                                {conexion.empresa_nombre && (
                                  <p><strong>Empresa:</strong> {conexion.empresa_nombre}</p>
                                )}
                                {conexion.aplicacion_nombre && (
                                  <p><strong>Aplicación:</strong> {conexion.aplicacion_nombre}</p>
                                )}
                                {conexion.modelo_nombre && (
                                  <p><strong>Modelo:</strong> {conexion.modelo_nombre}</p>
                                )}
                                {conexion.modelo_version && (
                                  <p><strong>Versión:</strong> {conexion.modelo_version}</p>
                                )}
                              </div>
                              <div style={{ marginTop: '10px', fontSize: '12px', color: '#007bff' }}>
                                Clic para seleccionar esta conexión
                              </div>
                            </div>
                          ))}
                        </>
                      )}
                    </div>
                  ) : (
                    <div className="agregar-conexion">
                      <h3>Agregar Nueva Conexión</h3>
                      <p style={{ marginBottom: '15px', color: '#666', fontSize: '14px' }}>
                        ℹ️ La empresa, aplicación y modelo se asignarán automáticamente usando los primeros registros disponibles en el sistema.
                      </p>
                      
                      <form onSubmit={handleSubmitConexion} className="form-conexion">
                        <div className="form-row">
                          <div className="form-group">
                            <label htmlFor="ip">Dirección IP:</label>
                            <input
                              type="text"
                              id="ip"
                              name="ip"
                              value={formData.ip}
                              onChange={handleInputChange}
                              placeholder="192.168.1.100"
                              required
                            />
                          </div>
                          <div className="form-group">
                            <label htmlFor="port">Puerto:</label>
                            <input
                              type="number"
                              id="port"
                              name="port"
                              value={formData.port}
                              onChange={handleInputChange}
                              placeholder="5432"
                              required
                            />
                          </div>
                        </div>

                        <div className="form-row">
                          <div className="form-group">
                            <label htmlFor="database_name">Nombre de Base de Datos:</label>
                            <input
                              type="text"
                              id="database_name"
                              name="database_name"
                              value={formData.database_name}
                              onChange={handleInputChange}
                              placeholder="nombre_database"
                              required
                            />
                          </div>
                        </div>

                        <div className="form-buttons">
                          <button type="submit" className="btn-submit">
                            Continuar con Credenciales
                          </button>
                          <button 
                            type="button" 
                            className="btn-cancel"
                            onClick={() => setCurrentView("listar")}
                          >
                            Cancelar
                          </button>
                        </div>
                      </form>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}

          {/* Modal de Login para conexión existente */}
          {showLoginModal && selectedConnection && (
            <div className="modal-conexiones">
              <div className="contenido-conexiones" style={{ maxWidth: '400px' }}>
                <span 
                  className="cerrar"
                  onClick={() => {
                    setShowLoginModal(false);
                    setSelectedConnection(null);
                    setLoginData({ username: '', password: '' });
                  }}
                >
                  &times;
                </span>
                <h2>Conectar a Base de Datos</h2>
                
                <div style={{ marginBottom: '20px', padding: '10px', backgroundColor: '#f8f9fa', borderRadius: '4px' }}>
                  <p><strong>Conexión:</strong> {selectedConnection.nombre || 'Sin nombre'}</p>
                  <p><strong>Servidor:</strong> {selectedConnection.ip}:{selectedConnection.puerto || selectedConnection.port}</p>
                  <p><strong>Base de Datos:</strong> {selectedConnection.database}</p>
                </div>
                
                <form onSubmit={handleLogin} className="form-conexion">
                  <div className="form-group">
                    <label>Usuario de Base de Datos:</label>
                    <input
                      type="text"
                      value={loginData.username}
                      onChange={(e) => setLoginData(prev => ({ ...prev, username: e.target.value }))}
                      placeholder="Ingrese su usuario"
                      required
                    />
                  </div>
                  <div className="form-group">
                    <label>Contraseña:</label>
                    <input
                      type="password"
                      value={loginData.password}
                      onChange={(e) => setLoginData(prev => ({ ...prev, password: e.target.value }))}
                      placeholder="Ingrese su contraseña"
                      required
                    />
                  </div>
                  <div className="form-buttons">
                    <button type="submit" className="btn-submit">
                      Conectar
                    </button>
                    <button 
                      type="button" 
                      className="btn-cancel"
                      onClick={() => {
                        setShowLoginModal(false);
                        setSelectedConnection(null);
                        setLoginData({ username: '', password: '' });
                      }}
                    >
                      Cancelar
                    </button>
                  </div>
                </form>
              </div>
            </div>
          )}

          {/* Modal de credenciales para nueva conexión */}
          {showCreateConnectionModal && tempConnectionData && (
            <div className="modal-conexiones">
              <div className="contenido-conexiones" style={{ maxWidth: '450px' }}>
                <span 
                  className="cerrar"
                  onClick={() => {
                    setShowCreateConnectionModal(false);
                    setTempConnectionData(null);
                    setLoginData({ username: '', password: '' });
                  }}
                >
                  &times;
                </span>
                <h2>Credenciales de Base de Datos</h2>
                
                <div style={{ marginBottom: '20px', padding: '10px', backgroundColor: '#f8f9fa', borderRadius: '4px' }}>
                  <p><strong>Nueva Conexión:</strong></p>
                  <p><strong>Servidor:</strong> {tempConnectionData.ip}:{tempConnectionData.port}</p>
                  <p><strong>Base de Datos:</strong> {tempConnectionData.database_name}</p>
                </div>
                
                <p style={{ marginBottom: '15px', color: '#666', fontSize: '14px' }}>
                  Para completar la creación de la conexión, proporcione las credenciales de acceso a la base de datos:
                </p>
                
                <form onSubmit={handleCreateConnectionWithCredentials} className="form-conexion">
                  <div className="form-group">
                    <label>Usuario de Base de Datos:</label>
                    <input
                      type="text"
                      value={loginData.username}
                      onChange={(e) => setLoginData(prev => ({ ...prev, username: e.target.value }))}
                      placeholder="Ingrese usuario de la base de datos"
                      required
                    />
                  </div>
                  <div className="form-group">
                    <label>Contraseña:</label>
                    <input
                      type="password"
                      value={loginData.password}
                      onChange={(e) => setLoginData(prev => ({ ...prev, password: e.target.value }))}
                      placeholder="Ingrese contraseña de la base de datos"
                      required
                    />
                  </div>
                  <div className="form-buttons">
                    <button type="submit" className="btn-submit">
                      Crear Conexión
                    </button>
                    <button 
                      type="button" 
                      className="btn-cancel"
                      onClick={() => {
                        setShowCreateConnectionModal(false);
                        setTempConnectionData(null);
                        setLoginData({ username: '', password: '' });
                      }}
                    >
                      Cancelar
                    </button>
                  </div>
                </form>
              </div>
            </div>
          )}
        </div>
      );
    }

    // Renderizar el componente
    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<DataSageHome />);
  </script>
</body>
</html>